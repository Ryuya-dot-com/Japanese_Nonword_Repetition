<!doctype html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>日本語復唱課題 録音</title>
  <style>
    :root {
      color-scheme: light;
      font-family: "Hiragino Sans", "Noto Sans JP", -apple-system, BlinkMacSystemFont, sans-serif;
      background: #f5f7fa;
      color: #1f2937;
    }
    body {
      margin: 0;
      padding: 24px;
      display: flex;
      justify-content: center;
      height: 100vh;
      overflow: hidden;
      box-sizing: border-box;
    }
    main {
      max-width: 960px;
      width: 100%;
      height: calc(100vh - 48px);
      background: #ffffff;
      border-radius: 16px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.06);
      padding: 24px 28px 24px;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    h1 {
      margin: 0 0 12px;
      font-size: 24px;
      letter-spacing: 0.02em;
    }
    p.lead {
      margin: 0 0 20px;
      color: #4b5563;
      line-height: 1.6;
    }
    section {
      margin-top: 12px;
    }
    .panel {
      border: 1px solid #e5e7eb;
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 16px;
      background: #f9fafb;
    }
    label {
      display: block;
      margin-bottom: 8px;
      font-weight: 600;
    }
    input[type="text"] {
      width: 100%;
      padding: 10px 12px;
      border: 1px solid #d1d5db;
      border-radius: 8px;
      font-size: 16px;
      box-sizing: border-box;
    }
    button {
      appearance: none;
      border: none;
      border-radius: 10px;
      padding: 12px 18px;
      font-size: 16px;
      font-weight: 700;
      cursor: pointer;
      color: #ffffff;
      background: linear-gradient(135deg, #2563eb, #1d4ed8);
      transition: transform 0.12s ease, box-shadow 0.12s ease, opacity 0.2s;
      box-shadow: 0 8px 18px rgba(37, 99, 235, 0.25);
    }
    button:disabled {
      opacity: 0.55;
      cursor: not-allowed;
      box-shadow: none;
    }
    button:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 10px 24px rgba(37, 99, 235, 0.3);
    }
    .danger {
      background: linear-gradient(135deg, #ef4444, #dc2626);
      box-shadow: 0 8px 18px rgba(239, 68, 68, 0.25);
    }
    .hidden {
      display: none;
    }
    .status-row {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 12px;
      margin-bottom: 12px;
    }
    .status-chip {
      background: #e5e7eb;
      border-radius: 20px;
      padding: 6px 12px;
      font-weight: 600;
      font-size: 14px;
      color: #111827;
    }
    .status-chip strong {
      margin-right: 6px;
    }
    .live {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }
    .live-indicator {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: #ef4444;
      box-shadow: 0 0 0 6px rgba(239, 68, 68, 0.15);
    }
    .pdf-shell {
      border: 1px solid #e5e7eb;
      border-radius: 12px;
      overflow: hidden;
      flex: 1;
      min-height: 0;
      background: #111827;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    #pdf-canvas {
      width: 100%;
      height: 100%;
      object-fit: contain;
      background: #1f2937;
    }
    .controls {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
      margin-top: 12px;
    }
    .note {
      color: #4b5563;
      font-size: 14px;
      margin-top: 4px;
    }
    .callout {
      background: #eef2ff;
      color: #312e81;
      border: 1px solid #c7d2fe;
      padding: 10px 12px;
      border-radius: 10px;
      font-size: 14px;
      margin-top: 8px;
    }
  </style>
</head>
<body>
  <main>
    <h1>日本語復唱課題 録音</h1>
    <p class="lead">受験者IDを入力して録音を開始します。スライドごとに自動で進行し、各スライドの録音が.wavでダウンロードされます。</p>

    <section id="setup-section" class="panel">
      <label for="participant-id">受験者ID</label>
      <input id="participant-id" type="text" placeholder="例: P001" />
      <div class="controls" style="margin-top: 12px;">
        <button id="start-session-btn">録音を開始</button>
        <span class="note">マイク許可が必要です。開始するとスライド1の録音が始まります。</span>
      </div>
    </section>

    <section id="session-section" class="hidden">
      <div class="status-row">
        <div class="status-chip">ID: <strong id="display-id">---</strong></div>
        <div class="status-chip">スライド: <strong id="slide-counter">1 / 11</strong></div>
        <div class="status-chip">
          <span class="live"><span class="live-indicator" id="live-dot"></span><span id="recording-label">待機中</span></span>
        </div>
        <div class="status-chip">音声: <strong id="audio-status">準備中</strong></div>
      </div>

      <div class="pdf-shell">
        <canvas id="pdf-canvas"></canvas>
      </div>

      <div class="controls">
        <button id="manual-start-btn" disabled>録音を手動で開始</button>
        <button id="stop-btn" class="danger" disabled>録音を停止</button>
        <div id="status-text" class="note">スライドを読み込み中...</div>
      </div>
      <div id="helper-text" class="callout hidden"></div>
    </section>
  </main>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script>
    pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";

    const pdfUrl = "日本語復唱課題.pdf";
    const totalSlides = 11;
    const pauseAfterSlide = 3;
    const autoStopMs = 8000; // 録音自動停止までの秒数（必要に応じて調整）
    const canvas = document.getElementById("pdf-canvas");
    const slideCounter = document.getElementById("slide-counter");
    const displayId = document.getElementById("display-id");
    const liveDot = document.getElementById("live-dot");
    const recordingLabel = document.getElementById("recording-label");
    const audioStatus = document.getElementById("audio-status");
    const statusText = document.getElementById("status-text");
    const helperText = document.getElementById("helper-text");
    const setupSection = document.getElementById("setup-section");
    const sessionSection = document.getElementById("session-section");
    const participantInput = document.getElementById("participant-id");
    const startButton = document.getElementById("start-session-btn");
    const manualStartButton = document.getElementById("manual-start-btn");
    const stopButton = document.getElementById("stop-btn");

    let pdfDoc = null;
    let currentSlide = 1;
    let stream = null;
    let mediaRecorder = null;
    let recordedChunks = [];
    let isRecording = false;
    let awaitingSpace = false;
    let pendingAutoStart = null;
    let audioContext = null;
    let participantId = "";
    let chosenMimeType = "";
    let promptAudio = new Audio();
    let autoStopTimer = null;

    const preferredMimeTypes = ["audio/webm;codecs=opus", "audio/webm", "audio/mp4", ""];

    const pickMimeType = () => {
      for (const type of preferredMimeTypes) {
        if (!type) {
          chosenMimeType = "";
          return chosenMimeType;
        }
        if (MediaRecorder.isTypeSupported(type)) {
          chosenMimeType = type;
          return chosenMimeType;
        }
      }
      chosenMimeType = "";
      return chosenMimeType;
    };

    const sleep = (ms) => new Promise((res) => setTimeout(res, ms));

    const pad2 = (num) => num.toString().padStart(2, "0");
    const formattedTimestamp = () => {
      const d = new Date();
      return (
        d.getFullYear().toString() +
        pad2(d.getMonth() + 1) +
        pad2(d.getDate()) +
        "_" +
        pad2(d.getHours()) +
        pad2(d.getMinutes()) +
        pad2(d.getSeconds())
      );
    };

    const setLiveState = (recording) => {
      isRecording = recording;
      liveDot.style.opacity = recording ? "1" : "0.35";
      liveDot.style.boxShadow = recording ? "0 0 0 6px rgba(239, 68, 68, 0.18)" : "none";
      recordingLabel.textContent = recording ? "録音中" : "待機中";
    };

    const setStatus = (text) => {
      statusText.textContent = text;
    };

    const setAudioStatus = (text) => {
      audioStatus.textContent = text;
    };

    const setHelper = (text) => {
      if (!text) {
        helperText.classList.add("hidden");
        helperText.textContent = "";
        return;
      }
      helperText.textContent = text;
      helperText.classList.remove("hidden");
    };

    const loadPromptAudio = (slideNumber) => {
      const src = `Slide${slideNumber}.wav`;
      promptAudio.pause();
      promptAudio.currentTime = 0;
      promptAudio.src = src;
      promptAudio.load();
      setAudioStatus(`準備中: ${src}`);
    };

    const playPromptAndMaybeRecord = async () => {
      stopButton.disabled = true;
      manualStartButton.disabled = true;
      setLiveState(false);
      loadPromptAudio(currentSlide);
      setStatus(`スライド${currentSlide}の音声を再生します...`);
      setAudioStatus(`再生中: Slide${currentSlide}.wav`);
      try {
        const playPromise = promptAudio.play();
        if (playPromise) {
          await playPromise;
        }
      } catch (err) {
        console.error(err);
        setStatus("スライド音声の再生に失敗しました。手動で録音を開始してください。");
        setAudioStatus("再生失敗");
        manualStartButton.disabled = false;
      }
    };

    promptAudio.onplay = () => {
      setAudioStatus(`再生中: Slide${currentSlide}.wav`);
    };

    promptAudio.onended = () => {
      setAudioStatus("録音準備中");
      setStatus("録音を開始します。");
      setTimeout(() => startRecordingForCurrentSlide(), 300);
    };

    promptAudio.onerror = () => {
      setStatus("スライド音声の読み込みに失敗しました。手動で録音を開始してください。");
      setAudioStatus("読み込み失敗");
      manualStartButton.disabled = false;
    };

    const renderSlide = async (pageNumber) => {
      if (!pdfDoc) {
        await setupPdf();
      }
      if (!pdfDoc) return;
      const page = await pdfDoc.getPage(pageNumber);
      const viewport = page.getViewport({ scale: 1.4 });
      const context = canvas.getContext("2d");
      canvas.width = viewport.width;
      canvas.height = viewport.height;
      await page.render({ canvasContext: context, viewport }).promise;
      slideCounter.textContent = `${pageNumber} / ${totalSlides}`;
    };

    const setupPdf = async () => {
      pdfDoc = await pdfjsLib.getDocument(pdfUrl).promise;
    };

    const ensureAudioContext = () => {
      if (!audioContext) {
        audioContext = new AudioContext();
      }
      if (audioContext.state === "suspended") {
        audioContext.resume();
      }
    };

    const bufferToWavBlob = (buffer) => {
      const numOfChan = buffer.numberOfChannels;
      const sampleRate = buffer.sampleRate;
      const format = 1; // PCM
      const bitDepth = 16;
      const bytesPerSample = bitDepth / 8;
      const blockAlign = numOfChan * bytesPerSample;
      const dataSize = buffer.length * blockAlign;
      const bufferLength = 44 + dataSize;
      const view = new DataView(new ArrayBuffer(bufferLength));

      const writeString = (offset, str) => {
        for (let i = 0; i < str.length; i++) {
          view.setUint8(offset + i, str.charCodeAt(i));
        }
      };

      writeString(0, "RIFF");
      view.setUint32(4, 36 + dataSize, true);
      writeString(8, "WAVE");
      writeString(12, "fmt ");
      view.setUint32(16, 16, true);
      view.setUint16(20, format, true);
      view.setUint16(22, numOfChan, true);
      view.setUint32(24, sampleRate, true);
      view.setUint32(28, sampleRate * blockAlign, true);
      view.setUint16(32, blockAlign, true);
      view.setUint16(34, bitDepth, true);
      writeString(36, "data");
      view.setUint32(40, dataSize, true);

      let offset = 44;
      for (let i = 0; i < buffer.length; i++) {
        for (let channel = 0; channel < numOfChan; channel++) {
          let sample = buffer.getChannelData(channel)[i];
          sample = Math.max(-1, Math.min(1, sample));
          view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7fff, true);
          offset += 2;
        }
      }
      return new Blob([view.buffer], { type: "audio/wav" });
    };

    const convertToWav = async (audioBlob) => {
      ensureAudioContext();
      const arrayBuffer = await audioBlob.arrayBuffer();
      const audioBuffer = await audioContext.decodeAudioData(arrayBuffer.slice(0));
      return bufferToWavBlob(audioBuffer);
    };

    const triggerDownload = (blob, filename) => {
      const url = URL.createObjectURL(blob);
      const anchor = document.createElement("a");
      anchor.href = url;
      anchor.download = filename;
      anchor.click();
      URL.revokeObjectURL(url);
    };

    const startRecordingForCurrentSlide = async () => {
      if (!stream || isRecording) return;
      if (promptAudio && !promptAudio.paused && !promptAudio.ended) return;
      recordedChunks = [];
      setLiveState(true);
      manualStartButton.disabled = true;
      stopButton.disabled = false;
      setStatus(`録音中: スライド${currentSlide}（${autoStopMs / 1000}秒で自動停止）`);
      try {
        const recorderOptions = chosenMimeType ? { mimeType: chosenMimeType } : undefined;
        mediaRecorder = recorderOptions ? new MediaRecorder(stream, recorderOptions) : new MediaRecorder(stream);
      } catch (err) {
        console.error(err);
        setStatus("このブラウザでは録音形式がサポートされていません。Chrome/Edgeなどでお試しください。");
        setLiveState(false);
        stopButton.disabled = true;
        return;
      }
      mediaRecorder.ondataavailable = (e) => {
        if (e.data && e.data.size > 0) {
          recordedChunks.push(e.data);
        }
      };
      mediaRecorder.onstop = handleRecordingStop;
      mediaRecorder.start();
      if (autoStopTimer) clearTimeout(autoStopTimer);
      autoStopTimer = setTimeout(() => {
        stopRecording();
      }, autoStopMs);
    };

    const stopRecording = () => {
      if (mediaRecorder && isRecording) {
        mediaRecorder.stop();
      }
      if (autoStopTimer) {
        clearTimeout(autoStopTimer);
        autoStopTimer = null;
      }
    };

    const advanceSlideAndRecord = async () => {
      if (currentSlide >= totalSlides) {
        setStatus("全スライドの録音が完了しました。");
        setHelper("");
        manualStartButton.disabled = true;
        stopButton.disabled = true;
        return;
      }
      currentSlide += 1;
      await renderSlide(currentSlide);
      setStatus(`スライド${currentSlide}の音声を再生します。`);
      await playPromptAndMaybeRecord();
    };

    const handleRecordingStop = async () => {
      setLiveState(false);
      stopButton.disabled = true;
      setStatus("保存処理中...");
      if (autoStopTimer) {
        clearTimeout(autoStopTimer);
        autoStopTimer = null;
      }

      try {
        const audioBlob = new Blob(recordedChunks, { type: chosenMimeType || "audio/webm" });
        const wavBlob = await convertToWav(audioBlob);
        const filename = `${participantId}_${formattedTimestamp()}_slide${pad2(currentSlide)}.wav`;
        triggerDownload(wavBlob, filename);
        setStatus(`保存しました: ${filename}`);
      } catch (err) {
        console.error(err);
        setStatus("録音の保存でエラーが発生しました。");
      } finally {
        recordedChunks = [];
      }

      if (currentSlide === pauseAfterSlide && currentSlide < totalSlides) {
        awaitingSpace = true;
        setHelper("スライド3完了。次に進むにはスペースキーを押してください。");
        manualStartButton.disabled = true;
        return;
      }
      await sleep(600);
      await advanceSlideAndRecord();
    };

    const startSession = async () => {
      participantId = participantInput.value.trim();
      if (!participantId) {
        alert("受験者IDを入力してください。");
        return;
      }
      if (typeof MediaRecorder === "undefined") {
        setStatus("このブラウザでは録音がサポートされていません。Chrome/Edgeでお試しください。");
        return;
      }
      startButton.disabled = true;
      setStatus("マイク許可をリクエストしています...");
      pickMimeType();
      try {
        stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      } catch (err) {
        console.error(err);
        setStatus("マイクの取得に失敗しました。権限を確認してください。");
        startButton.disabled = false;
        return;
      }
      ensureAudioContext();
      displayId.textContent = participantId;
      setupSection.classList.add("hidden");
      sessionSection.classList.remove("hidden");
      try {
        await renderSlide(currentSlide);
      } catch (err) {
        console.error(err);
        setStatus("PDFの読み込みに失敗しました。`python3 -m http.server 8000` などでローカルHTTPサーバーを起動してからブラウザで開いてください。");
        setHelper("PDFが表示されない場合は、ターミナルで `python3 -m http.server 8000` を実行し、http://localhost:8000/index.html を開いてください。");
        return;
      }
      setStatus("スライド1の音声を再生します。");
      await playPromptAndMaybeRecord();
    };

    const handleKeydown = (event) => {
      if (awaitingSpace && event.code === "Space") {
        event.preventDefault();
        awaitingSpace = false;
        setHelper("");
        advanceSlideAndRecord();
      }
    };

    startButton.addEventListener("click", startSession);
    manualStartButton.addEventListener("click", () => startRecordingForCurrentSlide());
    stopButton.addEventListener("click", stopRecording);
    window.addEventListener("keydown", handleKeydown);

    if (!window.isSecureContext) {
      setHelper("マイクを使うにはローカルHTTP(例: http://localhost:8000) またはHTTPSで開いてください。`python3 -m http.server 8000` を実行し、http://localhost:8000/index.html を開いてください。");
    }

    setupPdf()
      .then(() => renderSlide(currentSlide))
      .then(() => setStatus("スライド読み込み完了。IDを入力して開始してください。"))
      .catch((err) => {
        console.error(err);
        setStatus("PDFの読み込みに失敗しました。`python3 -m http.server 8000` でローカルサーバーを起動してから開いてください。");
        setHelper("ターミナルでこのフォルダに移動し、`python3 -m http.server 8000` を実行後、ブラウザで http://localhost:8000/index.html を開いてください。");
      });
  </script>
</body>
</html>
